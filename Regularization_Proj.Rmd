---
title: "Comparing Regularization Techniques on Simulated Data"
subtitle: 'A Variable Selection Project'
author:
- name: Franklin Fuchs
  affiliation: University of Nevada, Reno
output:
  html_document:
        toc: true 
        toc_float: true
        toc_depth: 2
        number_sections: true 
        theme: united
        highlight: tango
        keep_md: true
header-includes:
- \usepackage{amsmath}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
---


```{r, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, cache.comments=TRUE,echo = TRUE,fig.align = 'center', comment = NA, message=FALSE,warning=FALSE,error=FALSE,results='hold')

library(glmnet)
library(knitr) 
library(foreach)
library(MASS)
library(rlist)
library(dvmisc)
library(kableExtra)
library(ggplot2)
library(tidyr)
library(hrbrthemes)
library(viridis)

set.seed(122)
```

```{r, include=FALSE}
# All following functions were provided by Dr. Mihye Ahn

allpossible <- function(X, y){
  k <- dim(X)[2]
  p <- k+1
  
  myoutput <- matrix(0, 2^k, k+4) 
  colnames(myoutput) <- c(colnames(X), "Adj.R2", "MSE", "AIC", "BIC")
  
  i <- 1
  for (p2 in 0:k){
    allcomb <- combn(k, p2) 
    for (x2 in 1:dim(allcomb)[2]){
      if (p2==0){
        fit <- lm(y~1)
      }
      else{
        fit <- lm(y~as.matrix(X[,allcomb[,x2]]))
        myoutput[i, allcomb[,x2]] <- 1  # 1=included, 0=excluded
      }
      myoutput[i, k+1] <- summary(fit)$adj.r.squared  # Adjusted R^2
      myoutput[i, k+2] <- summary(fit)$sigma^2        # MSE
      myoutput[i, k+3] <- AIC(fit) # AIC
      myoutput[i, k+4] <- BIC(fit) # BIC
      i <- i+1
    }
  }
  myoutput <- as.data.frame(myoutput) 
  
  best1 <- myoutput[which.max(myoutput$Adj.R2), 1:k]
  best2 <- myoutput[which.min(myoutput$MSE), 1:k]
  best3 <- myoutput[which.min(myoutput$AIC), 1:k]
  best4 <- myoutput[which.min(myoutput$BIC), 1:k]
  object <- list(all=myoutput, Adj.R2=best1, MSE=best2, AIC=best3, BIC=best4)
  return(object)
}



# forward selection

forward <- function(X, y, method=c("F", "Adj.R2", "MSE", "AIC" , "BIC"), slentry=0.5){
  k <- dim(X)[2]
  p <- k+1

  if (method=="F"){
    best.old <- slentry 
    best.new <- 0
    selected.x <- array(F,k)
    p2 <- 0
    while (best.new < best.old & p2 < k){
      allcomb <- which(selected.x==F)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+2) 
      {
        if (sum(selected.x)==0)
          reduced <- lm(y~1)
        else 
          reduced <- lm(y~1+as.matrix(X[,selected.x]))
      }
      i <- 1
      for (x2 in 1:no){
        full.x <- selected.x 
        full.x[allcomb[x2]] <- T
        myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
        partialF <- anova(reduced, lm(y~as.matrix(X[,full.x])))
        myoutput[i, k+1] <- partialF$"F"[2]
        myoutput[i, k+2] <- partialF$"Pr(>F)"[2]
        i <- i+1
      }
      location <- which.max(myoutput[,k+1])
      best.new <- myoutput[location,k+2]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 + 1 
    }
  }
  
  # Adj.R2
  
  else if (method=="Adj.R2"){
    best.old <- -1 
    best.new <- 0
    selected.x <- array(F,k)
    p2 <- 0
    while (best.new > best.old & p2 < k){
      best.old <- best.new
      allcomb <- which(selected.x==F)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        full.x <- selected.x 
        full.x[allcomb[x2]] <- T
        myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- summary(lm(y~as.matrix(X[,full.x])))$adj.r.squared
        i <- i+1
      }
      location <- which.max(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new > best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 + 1 
    }
  }
 
  # MSE
  
  else if (method=="MSE"){
    best.old <- Inf
    best.new <- summary(lm(y~1))$sigma^2 
    selected.x <- array(F,k)
    p2 <- 0
    while (best.new < best.old & p2 < k){
      best.old <- best.new
      allcomb <- which(selected.x==F)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        full.x <- selected.x 
        full.x[allcomb[x2]] <- T
        myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- summary(lm(y~as.matrix(X[,full.x])))$sigma^2
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 + 1 
    } 
  }
 
  # AIC
  
  else if (method=="AIC"){
    best.old <- Inf
    best.new <- AIC(lm(y~1)) 
    selected.x <- array(F,k)
    p2 <- 0
    while (best.new < best.old & p2 < k){
      best.old <- best.new
      allcomb <- which(selected.x==F)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        full.x <- selected.x 
        full.x[allcomb[x2]] <- T
        myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- AIC(lm(y~as.matrix(X[,full.x])))
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 + 1 
    }  
  }
 
  # BIC
  
  else {  # method=="BIC"
    best.old <- Inf
    best.new <- BIC(lm(y~1)) 
    selected.x <- array(F,k)
    p2 <- 0
    while (best.new < best.old & p2 < k){
      best.old <- best.new
      allcomb <- which(selected.x==F)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        full.x <- selected.x 
        full.x[allcomb[x2]] <- T
        myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- BIC(lm(y~as.matrix(X[,full.x])))
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 + 1 
    }  
  }
  # for all
  selected.x <- as.matrix(selected.x,k,1)
  rownames(selected.x) <- colnames(X)
  return(selected.x)  
}


# backward elimination 

backward <- function(X, y, method=c("F", "Adj.R2", "MSE", "AIC" , "BIC"), slstay=0.10){
  k <- dim(X)[2]
  p <- k+1

  if (method=="F"){
    best.old <- slstay
    best.new <- 1
    selected.x <- array(T,k)
    p2 <- k
    while (best.new > best.old & p2 > 0){
      allcomb <- which(selected.x==T)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+2) 
      i <- 1
      for (x2 in 1:no){
        reduced.x <- selected.x 
        reduced.x[allcomb[x2]] <- F
        {
          if (no==1)
            reduced <- lm(y~1)
          else 
            reduced <- lm(y~1+as.matrix(X[,reduced.x]))
        }
        myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
        partialF <- anova(reduced, lm(y~1+as.matrix(X[,selected.x])))
        myoutput[i, k+1] <- partialF$"F"[2]
        myoutput[i, k+2] <- partialF$"Pr(>F)"[2]
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+2]
      if (best.new > best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 - 1 
    }
  }
  
  # Adj.R2
  
  else if (method=="Adj.R2"){
    best.old <- 0
    best.new <- summary(lm(y~X))$adj.r.squared 
    selected.x <- array(T,k)
    p2 <- k
    while (best.new > best.old & p2 > 0){
      best.old <- best.new
      allcomb <- which(selected.x==T)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        reduced.x <- selected.x 
        reduced.x[allcomb[x2]] <- F
        {
          if (no==1)
            fit <- lm(y~1)
          else 
            fit <- lm(y~1+as.matrix(X[,reduced.x]))
        }
        myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- summary(fit)$adj.r.squared
        i <- i+1
      }
      location <- which.max(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new > best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 - 1 
    }
  }
 
  # MSE
  
  else if (method=="MSE"){
    best.old <- Inf
    best.new <- summary(lm(y~X))$sigma^2 
    selected.x <- array(T,k)
    p2 <- k
    while (best.new < best.old & p2 > 0){
      best.old <- best.new
      allcomb <- which(selected.x==T)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        reduced.x <- selected.x 
        reduced.x[allcomb[x2]] <- F
        {
          if (no==1)
            fit <- lm(y~1)
          else 
            fit <- lm(y~1+as.matrix(X[,reduced.x]))
        }  
        myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- summary(fit)$sigma^2
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 - 1 
    } 
  }
 
  # AIC
  
  else if (method=="AIC"){
    best.old <- Inf
    best.new <- AIC(lm(y~X)) 
    selected.x <- array(T,k)
    p2 <- k
    while (best.new < best.old & p2 > 0){
      best.old <- best.new
      allcomb <- which(selected.x==T)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        reduced.x <- selected.x 
        reduced.x[allcomb[x2]] <- F
        {
          if (no==1)
            fit <- lm(y~1)
          else 
            fit <- lm(y~1+as.matrix(X[,reduced.x]))
        }  
        myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- AIC(fit)
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 - 1 
    }  
  }
 
  # BIC
  
  else {  # method=="BIC"
    best.old <- Inf
    best.new <- BIC(lm(y~X)) 
    selected.x <- array(T,k)
    p2 <- k
    while (best.new < best.old & p2 > 0){
      best.old <- best.new
      allcomb <- which(selected.x==T)
      no <- length(allcomb)
      myoutput <- matrix(0, no, k+1) 
      i <- 1
      for (x2 in 1:no){
        reduced.x <- selected.x 
        reduced.x[allcomb[x2]] <- F
        {
          if (no==1)
            fit <- lm(y~1)
          else 
            fit <- lm(y~1+as.matrix(X[,reduced.x]))
        }  
        myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
        myoutput[i, k+1] <- BIC(fit)
        i <- i+1
      }
      location <- which.min(myoutput[,k+1])
      best.new <- myoutput[location,k+1]
      if (best.new < best.old)
        selected.x <- myoutput[location,1:k]==1 
      p2 <- p2 - 1 
    }   
  }
  # for all
  selected.x <- as.matrix(selected.x,k,1)
  rownames(selected.x) <- colnames(X)
  return(selected.x) 
}




# Stepwise selection 

stepwise <- function(X, y, method=c("F", "Adj.R2", "MSE", "AIC" , "BIC"), slentry=0.15, slstay=0.15){
  k <- dim(X)[2]
  p <- k+1

  if (method=="F"){
    selected.x <- array(F,k)
    selected.x0 <- array(T,k) 
    selected.x00 <- array(T,k) 
    while (any(selected.x0 != selected.x) & any(selected.x00 != selected.x)){
      selected.x00 <- selected.x0 
      selected.x0 <- selected.x 
      candidate.add <- which(selected.x==F)
      candidate.remove <- which(selected.x==T)
      { # the first step (no variables in model)
        if (sum(selected.x)==0){ # go to addition step
          model.old <- lm(y~1)
          # addition     
          no <- length(candidate.add)
          myoutput <- matrix(0, no, k+2)
          i <- 1
          for (x2 in 1:no){
            full.x <- selected.x 
            full.x[candidate.add[x2]] <- T
            myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
            partialF <- anova(model.old, lm(y~1+as.matrix(X[,full.x])))
            myoutput[i, k+1] <- partialF$"F"[2]
            myoutput[i, k+2] <- partialF$"Pr(>F)"[2]
            i <- i+1
          }
          location <- which.max(myoutput[,k+1])
          best.new <- myoutput[location,k+2]
          if (best.new < slentry)
            selected.x <- myoutput[location,1:k]==1 
        }
        # if model has one or more variables
        else { # go to deletion step first 
          model.old <- lm(y~1+as.matrix(X[,selected.x]))
          # deletion 
          no <- length(candidate.remove)
          myoutput <- matrix(0, no, k+1) 
          i <- 1
          for (x2 in 1:no){
            reduced.x <- selected.x 
            reduced.x[candidate.remove[x2]] <- F
            myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
            i <- i+1
          }
          myoutput[,k+1] <- summary(model.old)$coef[2:(sum(selected.x)+1),4]
          location <- which.max(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          {
            if (best.new > slstay)  # in this case, we don't go to addition step. 
              selected.x <- myoutput[location,1:k]==1 
            else{ # no deletion, then go to addition step
              # addition     
              no <- length(candidate.add)
              myoutput <- matrix(0, no, k+2)
              i <- 1
              for (x2 in 1:no){
                full.x <- selected.x 
                full.x[candidate.add[x2]] <- T
                myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
                partialF <- anova(model.old, lm(y~1+as.matrix(X[,full.x])))
                myoutput[i, k+1] <- partialF$"F"[2]
                myoutput[i, k+2] <- partialF$"Pr(>F)"[2]
                i <- i+1
              }
              location <- which.max(myoutput[,k+1])
              best.new <- myoutput[location,k+2]
              if (best.new < slentry)
                selected.x <- myoutput[location,1:k]==1 
            }
          }
        }
      }
    } # while
    selected.x <- selected.x0 
  } # end
  
  # Adj.R2
  
  else if (method=="Adj.R2"){
    selected.x <- array(F,k)
    selected.x0 <- array(T,k) 
    selected.x00 <- array(T,k) 
    best.new <- 0 
    while (any(selected.x0 != selected.x) & any(selected.x00 != selected.x)){
      selected.x00 <- selected.x0 
      selected.x0 <- selected.x 
      candidate.add <- which(selected.x==F)
      candidate.remove <- which(selected.x==T)
      best.old <- best.new
      { # the first step (no variables in model)
        if (sum(selected.x)==0){ # go to addition step
          # addition     
          no <- length(candidate.add)
          myoutput <- matrix(0, no, k+1)
          i <- 1
          for (x2 in 1:no){
            full.x <- selected.x 
            full.x[candidate.add[x2]] <- T
            myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
            myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,full.x])))$adj.r.squared
            i <- i+1
          }
          location <- which.max(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          if (best.new > best.old)
            selected.x <- myoutput[location,1:k]==1       
        }
        # if model has one or more variables
        else { # go to deletion step first 
          # deletion 
          no <- length(candidate.remove)
          myoutput <- matrix(0, no, k+1) 
          i <- 1
          for (x2 in 1:no){
            reduced.x <- selected.x 
            reduced.x[candidate.remove[x2]] <- F
            myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
            {
              if (sum(reduced.x)==0)
                myoutput[i, k+1] <- summary(lm(y~1))$adj.r.squared
              else 
                myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,reduced.x])))$adj.r.squared
            }
            i <- i+1
          }
          location <- which.max(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          {
            if (best.new > best.old)  # in this case, we don't go to addition step. 
              selected.x <- myoutput[location,1:k]==1 
            else{ # no deletion, then go to addition step
              # addition     
              no <- length(candidate.add)
              myoutput <- matrix(0, no, k+1)
              i <- 1
              for (x2 in 1:no){
                full.x <- selected.x 
                full.x[candidate.add[x2]] <- T
                myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
                myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,full.x])))$adj.r.squared
                i <- i+1
              }
              location <- which.max(myoutput[,k+1])
              best.new <- myoutput[location,k+1]
              if (best.new > best.old)
                selected.x <- myoutput[location,1:k]==1 
            }
          }
        }
      }
    } # while
    selected.x <- selected.x0 
  } # end
 
  # MSE
  
  else if (method=="MSE"){
    selected.x <- array(F,k)
    selected.x0 <- array(T,k) 
    selected.x00 <- array(T,k) 
    best.new <- summary(lm(y~1))$sigma^2 
    while (any(selected.x0 != selected.x) & any(selected.x00 != selected.x)){
      selected.x00 <- selected.x0 
      selected.x0 <- selected.x 
      candidate.add <- which(selected.x==F)
      candidate.remove <- which(selected.x==T)
      best.old <- best.new
      { # the first step (no variables in model)
        if (sum(selected.x)==0){ # go to addition step
          # addition     
          no <- length(candidate.add)
          myoutput <- matrix(0, no, k+1)
          i <- 1
          for (x2 in 1:no){
            full.x <- selected.x 
            full.x[candidate.add[x2]] <- T
            myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
            myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,full.x])))$sigma^2
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          if (best.new < best.old)
            selected.x <- myoutput[location,1:k]==1       
        }
        # if model has one or more variables
        else { # go to deletion step first 
          # deletion 
          no <- length(candidate.remove)
          myoutput <- matrix(0, no, k+1) 
          i <- 1
          for (x2 in 1:no){
            reduced.x <- selected.x 
            reduced.x[candidate.remove[x2]] <- F
            myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
            {
              if (sum(reduced.x)==0)
                myoutput[i, k+1] <- summary(lm(y~1))$sigma^2
              else 
                myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,reduced.x])))$sigma^2
            }
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          {
            if (best.new < best.old)  # in this case, we don't go to addition step. 
              selected.x <- myoutput[location,1:k]==1 
            else{ # no deletion, then go to addition step
              # addition     
              no <- length(candidate.add)
              myoutput <- matrix(0, no, k+1)
              i <- 1
              for (x2 in 1:no){
                full.x <- selected.x 
                full.x[candidate.add[x2]] <- T
                myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
                myoutput[i, k+1] <- summary(lm(y~1+as.matrix(X[,full.x])))$sigma^2
                i <- i+1
              }
              location <- which.min(myoutput[,k+1])
              best.new <- myoutput[location,k+1]
              if (best.new < best.old)
                selected.x <- myoutput[location,1:k]==1 
            }
          }
        }
      }
    } # while
    selected.x <- selected.x0 
  } # end
 
  # AIC
  
  else if (method=="AIC"){
    selected.x <- array(F,k)
    selected.x0 <- array(T,k) 
    selected.x00 <- array(T,k) 
    best.new <- AIC(lm(y~1))
    while (any(selected.x0 != selected.x) & any(selected.x00 != selected.x)){
      selected.x00 <- selected.x0 
      selected.x0 <- selected.x 
      candidate.add <- which(selected.x==F)
      candidate.remove <- which(selected.x==T)
      best.old <- best.new
      { # the first step (no variables in model)
        if (sum(selected.x)==0){ # go to addition step
          # addition     
          no <- length(candidate.add)
          myoutput <- matrix(0, no, k+1)
          i <- 1
          for (x2 in 1:no){
            full.x <- selected.x 
            full.x[candidate.add[x2]] <- T
            myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
            myoutput[i, k+1] <- AIC(lm(y~1+as.matrix(X[,full.x])))
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          if (best.new < best.old)
            selected.x <- myoutput[location,1:k]==1       
        }
        # if model has one or more variables
        else { # go to deletion step first 
          # deletion 
          no <- length(candidate.remove)
          myoutput <- matrix(0, no, k+1) 
          i <- 1
          for (x2 in 1:no){
            reduced.x <- selected.x 
            reduced.x[candidate.remove[x2]] <- F
            myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
            {
              if (sum(reduced.x)==0)
                myoutput[i, k+1] <- AIC(lm(y~1))
              else 
                myoutput[i, k+1] <- AIC(lm(y~1+as.matrix(X[,reduced.x])))
            }
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          {
            if (best.new < best.old)  # in this case, we don't go to addition step. 
              selected.x <- myoutput[location,1:k]==1 
            else{ # no deletion, then go to addition step
              # addition     
              no <- length(candidate.add)
              myoutput <- matrix(0, no, k+1)
              i <- 1
              for (x2 in 1:no){
                full.x <- selected.x 
                full.x[candidate.add[x2]] <- T
                myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
                myoutput[i, k+1] <- AIC(lm(y~1+as.matrix(X[,full.x])))
                i <- i+1
              }
              location <- which.min(myoutput[,k+1])
              best.new <- myoutput[location,k+1]
              if (best.new < best.old)
                selected.x <- myoutput[location,1:k]==1 
            }
          }
        }
      }
    } # while
    selected.x <- selected.x0 
  } # end
 
  # BIC
  
  else {  # method=="BIC"
    selected.x <- array(F,k)
    selected.x0 <- array(T,k) 
    selected.x00 <- array(T,k) 
    best.new <- BIC(lm(y~1))
    while (any(selected.x0 != selected.x) & any(selected.x00 != selected.x)){
      selected.x00 <- selected.x0 
      selected.x0 <- selected.x 
      candidate.add <- which(selected.x==F)
      candidate.remove <- which(selected.x==T)
      best.old <- best.new
      { # the first step (no variables in model)
        if (sum(selected.x)==0){ # go to addition step
          # addition     
          no <- length(candidate.add)
          myoutput <- matrix(0, no, k+1)
          i <- 1
          for (x2 in 1:no){
            full.x <- selected.x 
            full.x[candidate.add[x2]] <- T
            myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
            myoutput[i, k+1] <- BIC(lm(y~1+as.matrix(X[,full.x])))
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          if (best.new < best.old)
            selected.x <- myoutput[location,1:k]==1       
        }
        # if model has one or more variables
        else { # go to deletion step first 
          # deletion 
          no <- length(candidate.remove)
          myoutput <- matrix(0, no, k+1) 
          i <- 1
          for (x2 in 1:no){
            reduced.x <- selected.x 
            reduced.x[candidate.remove[x2]] <- F
            myoutput[i, 1:k] <- reduced.x  # 1=included, 0=excluded
            {
              if (sum(reduced.x)==0)
                myoutput[i, k+1] <- BIC(lm(y~1))
              else 
                myoutput[i, k+1] <- BIC(lm(y~1+as.matrix(X[,reduced.x])))
            }
            i <- i+1
          }
          location <- which.min(myoutput[,k+1])
          best.new <- myoutput[location,k+1]
          {
            if (best.new < best.old)  # in this case, we don't go to addition step. 
              selected.x <- myoutput[location,1:k]==1 
            else{ # no deletion, then go to addition step
              # addition     
              no <- length(candidate.add)
              myoutput <- matrix(0, no, k+1)
              i <- 1
              for (x2 in 1:no){
                full.x <- selected.x 
                full.x[candidate.add[x2]] <- T
                myoutput[i, 1:k] <- full.x  # 1=included, 0=excluded
                myoutput[i, k+1] <- BIC(lm(y~1+as.matrix(X[,full.x])))
                i <- i+1
              }
              location <- which.min(myoutput[,k+1])
              best.new <- myoutput[location,k+1]
              if (best.new < best.old)
                selected.x <- myoutput[location,1:k]==1 
            }
          }
        }
      }
    } # while
    selected.x <- selected.x0 
  } # end
  
  # for all
  selected.x <- as.matrix(selected.x,k,1)
  rownames(selected.x) <- colnames(X)
  return(selected.x) 
}
```

# Introduction

The aims of this project are to simulate multivariate data from underlying linear models with varying degrees of correlation among predictors and then observing how effective different variable selection methods perform on each dataset by fitting a linear regression model with the selected variables. Thus, we first simulate 50 datasets for every underlying model from section 7 of the Paper "Regression Shrinkage and Selection via the Lasso" by Tibshirani (1996). We then fit the models according several variable selection and shrinkage methods. Finally, we use mean and median Mean Square Error to compare performances. The following models will be compared. The immediate next step for this project is to add performance metrics such as AIC and BIC in addition to the mean and median MSE to better capture model performances. I also want to vectorize all loops and generally reduce redudant variable storage where possible.

* Ordinary Least Squares Regression (No Variable Selection)
* LASSO Regression
* Ridge Regression
* All possible Regression
* Forward Selection Regression
* Backward Elimination Regression
* Stepwise Selection


# Simulating Datasets

In this section we simulate data from the four aforementioned underlying models.

## Underlying Model 1

Data from the first underlying model consists of 50 simulated datasets with 20 observations each, from the underlying model as outlined by Tibshirani (1996) we have the model such that $\boldsymbol{\beta}=(3,1.5,0,0,2,0,0,0)^T$ , and $\sigma=3$, and the correlation between $x_i$ and $x_j$ as $\rho^{|i-j|}$ where $\rho=0.5$. Thus, we have the model as

$$
y = \boldsymbol{\beta}^{T}\boldsymbol{x} + \sigma\boldsymbol{\epsilon}
$$
R-Implementation:
```{r}
# Variable Declarations
n_obs1 <- 20
n_simul1 <-50
p1 <- 8
corr1 <- 0.5
sigma1 <- 3
beta1 <- c(3, 1.5 ,0 ,0 ,2 ,0, 0, 0)

# Simulating The Matrix of Predictors
CovarMat1 <- outer(1:length(beta1), 1:length(beta1), function(i,j){corr1^abs(i-j)})
mean_vect1 <- rep(0,length(beta1))
X_n_simul1 <- list()
for(i in 1:n_simul1){ 
  X_n_simul1[[i]] <- as.matrix(mvrnorm(n = n_obs1,mu = mean_vect1,Sigma =  CovarMat1))
}

# Generate Y
epsilon1 <- rnorm(n_obs1,mean = 0,sd = sigma1)
y_n_simul1 <- list()
for(i in 1:n_simul1){
  y_n_simul1[[i]] <-  X_n_simul1[[i]] %*% beta1 + epsilon1
}
```

## Underlying Model 2

Data from the second underlying model also consists of 50 simulated datasets with 20 observations each with the same model structure as for model 1, but now with parameter values $\beta_{j}=0.85$ for every $j$, and $\sigma=3$, and the correlation between $x_i$ and $x_j$ as $\rho^{|i-j|}$ where $\rho=0.5$.

R-Implementation:
```{r}
# Variable declarations
n_obs2 <- 20
n_simul2 <-50
p2 <- 8
corr2 <- 0.5
sigma2 <- 3
beta2 <- c(0.85, 0.85, 0.85 ,0.85 ,0.85 ,0.85 ,0.85 ,0.85)

#Simulating Matrix of Predictors
CovarMat2 <- outer(1:length(beta2), 1:length(beta2), function(i,j){corr2^abs(i-j)})
mean_vect2 <- rep(0,length(beta2))
X_n_simul2 <- list()
for(i in 1:n_simul2){ 
  X_n_simul2[[i]] <- as.matrix(mvrnorm(n = n_obs2,mu = mean_vect2,Sigma =  CovarMat2))
}

#Generate Y
epsilon2 <- rnorm(n_obs2,mean = 0,sd = sigma2)
y_n_simul2 <- list()
for(i in 1:n_simul2){
  y_n_simul2[[i]] <-  X_n_simul2[[i]] %*% beta2 + epsilon2
}
```

## Underlying Model 3

Data from the third underlying model also consists of 50 simulated datasets with 20 observations each with the same model structure as for model 1, but now with parameter values $\boldsymbol{\beta}=(5,0,0,0,0,0,0,0)^T$, and $\sigma=2$, and the correlation between $x_i$ and $x_j$ as $\rho^{|i-j|}$ where $\rho=0.5$.

R-Implementation:
```{r}
# Variable declaration for simulating dataset
n_obs3 <- 20
n_simul3 <-50
p3 <- 8
corr3 <- 0.5
sigma3 <- 2
beta3 <- c(5, 0, 0, 0, 0, 0, 0, 0)

#Simulating matrix of predictors X
CovarMat3 <- outer(1:length(beta3), 1:length(beta3), function(i,j){corr3^abs(i-j)})
mean_vect3 <- rep(0,length(beta3))
X_n_simul3 <- list()
for(i in 1:n_simul3){ 
  X_n_simul3[[i]] <- as.matrix(mvrnorm(n = n_obs3,mu = mean_vect3,Sigma =  CovarMat3))
}

#Generate y from X 

epsilon3 <- rnorm(n_obs3,mean = 0,sd = sigma3)
y_n_simul3 <- list()
for(i in 1:n_simul3){
  y_n_simul3[[i]] <-  X_n_simul3[[i]] %*% beta3 + epsilon3
}
```

# Fitting Models

In this section, we fit the regression models and measure performance for each underlying model

## OLS Regression

We first fit the OLS Regression Model and measure model performances. It is important to mention that no predictors are discarded for OLS Regression. We have the data as $(\boldsymbol{x}^{i},y_i)$ for $i=1,2,...,N$, where $\boldsymbol{x}^{i}=(x_{i1},...,x_{ip})^T$, and according to Garet et al. (2013) we thus estimate $\beta_{0},\beta_{1},...,\beta_{p}$ to minimize

$$
\text{RSS} =  \sum^{n}_{i=1}\left(y_{i}-\beta_{0}-\sum^{p}_{j=1}\beta_{j}x_{ij}\right)^2
$$

R-Implementation:
```{r}
#Underlying Model 1
OLS_MSE_Data1 <- vector(length = n_simul1)

for(i in 1:n_simul1){
  OLS_fit1 <- lm(y_n_simul1[[i]]~X_n_simul1[[i]])
  OLS_MSE_Data1[i] <-  get_mse(OLS_fit1,var.estimate = FALSE)
}

mean_OLS_MSE_Data1 <- mean(OLS_MSE_Data1)
median_OLS_MSE_Data1 <- median(OLS_MSE_Data1)
OLS_row1 <- cbind("OLS",mean_OLS_MSE_Data1,median_OLS_MSE_Data1)

#Underlying Model 2
OLS_MSE_Data2 <- vector(length = n_simul2)

for(i in 1:n_simul2){
  OLS_fit2 <- lm(y_n_simul2[[i]]~X_n_simul2[[i]])
  OLS_MSE_Data2[i] <-  get_mse(OLS_fit2,var.estimate = FALSE)
}

mean_OLS_MSE_Data2 <- mean(OLS_MSE_Data2)
median_OLS_MSE_Data2 <- median(OLS_MSE_Data2)
OLS_row2 <- cbind("OLS",mean_OLS_MSE_Data2,median_OLS_MSE_Data2)

#Underlying Model 3
OLS_MSE_Data3 <- vector(length = n_simul3)

for(i in 1:n_simul3){
  OLS_fit3 <- lm(y_n_simul3[[i]]~X_n_simul3[[i]])
  OLS_MSE_Data3[i] <-  get_mse(OLS_fit3,var.estimate = FALSE)
}

mean_OLS_MSE_Data3 <- mean(OLS_MSE_Data3)
median_OLS_MSE_Data3 <- median(OLS_MSE_Data3)
OLS_row3 <- cbind("OLS",mean_OLS_MSE_Data3,median_OLS_MSE_Data3)
```

## LASSO Regression

We now fit the LASSO with 10-fold cross-validation, measure model performances, and outline the LASSO technique according to Tibshirani (1996). We have the data as $(\boldsymbol{x}^{i},y_i)$ for $i=1,2,...,N$, where $\boldsymbol{x}^{i}=(x_{i1},...,x_{ip})^T$ and the predictors are standardized. Additionally, we define $\boldsymbol{\hat{\beta}}=(\hat{\beta}_{1},...,\hat{\beta}_{p})^T$ and tuning parameter $t\geq0$ and so the LASSO estimate $(\boldsymbol{\hat{\alpha}},\boldsymbol{\hat{\beta}})$ is defined as

$$
(\boldsymbol{\hat{\alpha}},\boldsymbol{\hat{\beta}})=\text{arg min}\left\{\sum^{N}_{i=1}(y_i-\alpha-\sum_{j}\beta_{j}x_{ij})^2\right\} \text{   subject to } \sum_{j}|\beta_j|\leq t
$$

R-Implementation:
```{r}
#Underlying Model 1
LASSO_MSE_Data1 <- vector(length = n_simul1)

for(i in 1:n_simul1){
  lasso_fit1 = glmnet(X_n_simul1[[i]], y_n_simul1[[i]], alpha = 1, family="gaussian")
  crossval1 = cv.glmnet(X_n_simul1[[i]], y_n_simul1[[i]],
                       alpha = 1, nfolds = 10,grouped = FALSE)
  lambda1 = crossval1$lambda.min
  y_hat1 = predict(lasso_fit1, s = lambda1, newx = X_n_simul1[[i]])
  LASSO_MSE_Data1[i] <- mean((y_hat1 - y_n_simul1[[i]])^2)
}

mean_LASSO_MSE_Data1 <- mean(LASSO_MSE_Data1)
median_LASSO_MSE_Data1 <- median(LASSO_MSE_Data1)
LASSO_row1 <- cbind("LASSO",mean_LASSO_MSE_Data1, median_LASSO_MSE_Data1)

#Underlying Model 2
LASSO_MSE_Data2 <- vector(length = n_simul2)

for(i in 1:n_simul2){
  lasso_fit2 = glmnet(X_n_simul2[[i]], y_n_simul2[[i]], alpha = 1, family="gaussian")
  crossval2 = cv.glmnet(X_n_simul2[[i]], y_n_simul2[[i]],
                       alpha = 1, nfolds = 10,grouped = FALSE)
  lambda2 = crossval2$lambda.min
  y_hat2 = predict(lasso_fit2, s = lambda2, newx = X_n_simul2[[i]])
  LASSO_MSE_Data2[i] <- mean((y_hat2 - y_n_simul2[[i]])^2)
}

mean_LASSO_MSE_Data2 <- mean(LASSO_MSE_Data2)
median_LASSO_MSE_Data2 <- median(LASSO_MSE_Data2)
LASSO_row2 <- cbind("LASSO",mean_LASSO_MSE_Data2, median_LASSO_MSE_Data2)

#Underlying Model 3
LASSO_MSE_Data3 <- vector(length = n_simul3)

for(i in 1:n_simul3){
  lasso_fit3 = glmnet(X_n_simul3[[i]], y_n_simul3[[i]], alpha = 1, family="gaussian")
  crossval3 = cv.glmnet(X_n_simul3[[i]], y_n_simul3[[i]],
                       alpha = 1, nfolds = 10,grouped = FALSE)
  lambda3 = crossval3$lambda.min
  y_hat3 = predict(lasso_fit3, s = lambda3, newx = X_n_simul3[[i]])
  LASSO_MSE_Data3[i] <- mean((y_hat3 - y_n_simul3[[i]])^2)
}

mean_LASSO_MSE_Data3 <- mean(LASSO_MSE_Data3)
median_LASSO_MSE_Data3 <- median(LASSO_MSE_Data3)
LASSO_row3 <- cbind("LASSO",mean_LASSO_MSE_Data3, median_LASSO_MSE_Data3)
```

## Ridge Regression

We now fit the Ridge with 10-fold cross-validation, measure model performances, and outline the Ridge Regression technique according to Gareth James et al. (2013). Ridge Regression has a similar setup to OLS, although the quantity to be minimized is different than for OLS and LASSO Regression. We define tuning parameter $\lambda \geq 0$, and so we have regression coefficient estimates $\boldsymbol{\hat{\beta}}$ to minimize 

$$
\sum_{i=1}^{n}\left(y_{i}-\beta_{0}-\sum_{j=1}^{p}\beta_{j}x_{ij}\right)^2 + \lambda\sum^{p}_{j=1}\beta^{2}_{j}
$$
R-Implementation:
```{r}
#Underlying Model 1
Ridge_MSE_Data1 <- vector(length = n_simul1)

for(i in 1:n_simul1){
  Ridge_fit1 = glmnet(X_n_simul1[[i]], y_n_simul1[[i]], alpha = 0, family="gaussian")
  crossval1 = cv.glmnet(X_n_simul1[[i]], y_n_simul1[[i]],
                       alpha = 0, nfolds = 10,grouped = FALSE)
  lambda1 = crossval1$lambda.min
  y_hat1 = predict(Ridge_fit1, s = lambda1, newx = X_n_simul1[[i]])
  Ridge_MSE_Data1[i] <- mean((y_hat1 - y_n_simul1[[i]])^2)
}

mean_Ridge_MSE_Data1 <- mean(Ridge_MSE_Data1)
median_Ridge_MSE_Data1 <- median(Ridge_MSE_Data1)
Ridge_row1 <- cbind("Ridge",mean_Ridge_MSE_Data1,median_Ridge_MSE_Data1)

#Underlying Model 2
Ridge_MSE_Data2 <- vector(length = n_simul2)

for(i in 1:n_simul2){
  Ridge_fit2 = glmnet(X_n_simul2[[i]], y_n_simul2[[i]], alpha = 0, family="gaussian")
  crossval2 = cv.glmnet(X_n_simul2[[i]], y_n_simul2[[i]],
                       alpha = 0, nfolds = 10,grouped = FALSE)
  lambda2 = crossval2$lambda.min
  y_hat2 = predict(Ridge_fit2, s = lambda2, newx = X_n_simul2[[i]])
  Ridge_MSE_Data2[i] <- mean((y_hat2 - y_n_simul2[[i]])^2)
}

mean_Ridge_MSE_Data2 <- mean(Ridge_MSE_Data2)
median_Ridge_MSE_Data2 <- median(Ridge_MSE_Data2)
Ridge_row2 <- cbind("Ridge",mean_Ridge_MSE_Data2,median_Ridge_MSE_Data2)

#Underlying Model 3
Ridge_MSE_Data3 <- vector(length = n_simul3)

for(i in 1:n_simul3){
  Ridge_fit3 = glmnet(X_n_simul3[[i]], y_n_simul3[[i]], alpha = 0, family="gaussian")
  crossval3 = cv.glmnet(X_n_simul3[[i]], y_n_simul3[[i]],
                       alpha = 0, nfolds = 10,grouped = FALSE)
  lambda3 = crossval3$lambda.min
  y_hat3 = predict(Ridge_fit3, s = lambda3, newx = X_n_simul3[[i]])
  Ridge_MSE_Data3[i] <- mean((y_hat3 - y_n_simul3[[i]])^2)
}

mean_Ridge_MSE_Data3 <- mean(Ridge_MSE_Data3)
median_Ridge_MSE_Data3 <- median(Ridge_MSE_Data3)
Ridge_row3 <- cbind("Ridge",mean_Ridge_MSE_Data3,median_Ridge_MSE_Data3)
```

## All Possible Regression

We now fit All Possible Regression Models, measure model performances, and outline the All Possible Regression technique according to Hocking (1976). All Possible Regression is a computationally intensive variable selection technique where given that the number of predictors $t$ is not too large since the number of all possible models is $2^t$, then all possible models will be fit and the model with the best performance will be selected. It is important to mention that Hocking (1976) emphasizes approaches and modifications to All Possible Regression that optimize the procedure for evaluating all possible subsets, which we will not further consider for this project.

R-Implementation:
```{r}
# Underlying Model 1
All_possible_MSE_Data1 <- list()

for(i in 1:n_simul1){
  sig1 <- allpossible(data.frame(X_n_simul1[[i]]),matrix(y_n_simul1[[i]]))$AIC==1
  All_possible_fit1 <- lm(y_n_simul1[[i]] ~ X_n_simul1[[i]][,sig1]+0)
  b1 = array(0,8)
  b1[sig1] = coef(All_possible_fit1)
  All_possible_MSE_Data1[[i]] <-  t(beta1-b1)%*%CovarMat1%*%(beta1-b1)
}

mean_All_possible_MSE_Data1 <- mean(unlist(All_possible_MSE_Data1))
median_All_possible_MSE_Data1 <- median(unlist(All_possible_MSE_Data1))
All_possible_row1 <- cbind("All possible Regression",
                         mean_All_possible_MSE_Data1,median_All_possible_MSE_Data1)

# Underlying Model 2
All_possible_MSE_Data2 <- list()

for(i in 1:n_simul2){
  sig2 <- allpossible(data.frame(X_n_simul2[[i]]),matrix(y_n_simul2[[i]]))$AIC==1
  All_possible_fit2 <- lm(y_n_simul2[[i]] ~ X_n_simul2[[i]][,sig2]+0)
  b2 = array(0,8)
  b2[sig2] = coef(All_possible_fit2)
  All_possible_MSE_Data2[[i]] <-  t(beta2-b2)%*%CovarMat2%*%(beta2-b2)
}

mean_All_possible_MSE_Data2 <- mean(unlist(All_possible_MSE_Data2))
median_All_possible_MSE_Data2 <- median(unlist(All_possible_MSE_Data2))
All_possible_row2<- cbind("All possible Regression",
                         mean_All_possible_MSE_Data2,median_All_possible_MSE_Data2)

# Underlying Model 3
All_possible_MSE_Data3 <- list()

for(i in 1:n_simul3){
  sig3 <- allpossible(data.frame(X_n_simul3[[i]]),matrix(y_n_simul3[[i]]))$AIC==1
  All_possible_fit3 <- lm(y_n_simul3[[i]] ~ X_n_simul3[[i]][,sig3]+0)
  b3 = array(0,8)
  b3[sig3] = coef(All_possible_fit3)
  All_possible_MSE_Data3[[i]] <-  t(beta3-b3)%*%CovarMat3%*%(beta3-b3)
}

mean_All_possible_MSE_Data3 <- mean(unlist(All_possible_MSE_Data3))
median_All_possible_MSE_Data3 <- median(unlist(All_possible_MSE_Data3))
All_possible_row3<- cbind("All possible Regression",
                         mean_All_possible_MSE_Data3,median_All_possible_MSE_Data3)
```

## Forward Selection

We now fit Forward Selection Regression Models with a cutoff p-value of $0.5$ for the $F$-statistic outlined below, measure model performances, and outline the Forward Selection technnique. According to Hocking (1976) the Forward Selection technique starts with no variables and adds one variable at a time to the equation until either all variables are in or a criteria to stop the technique is satisfied. Furthermore, the variable considered for inclusion at any step is the one yielding the largest F-ratio among the variables being considered for inclusion. Thus, the variable $i$ is added to the equation of $p$-terms if

$$
F_{i} = \underset{i}{\max}\left(\frac{RSS_{p} - RSS_{p+i}}{\hat{\sigma}_{p+i}^2}\right) > F_{in}
$$
R-Implementation:
```{r}
#Underlying Model 1
forward_MSE_Data1 <- list()

for(i in 1:n_simul1){
  sig1 <- forward(data.frame(X_n_simul1[[i]]),matrix(y_n_simul1[[i]]),"BIC",slentry = 0.5)
  forward_fit1 <- lm(y_n_simul1[[i]] ~ X_n_simul1[[i]][,sig1]+0)
  b1 = array(0,8)
  b1[sig1] = coef(forward_fit1)
  forward_MSE_Data1[[i]] <-   t(beta1-b1)%*%CovarMat1%*%(beta1-b1)
}

mean_forward_MSE_Data1 <- mean(unlist(forward_MSE_Data1))
median_forward_MSE_Data1 <- median(unlist(forward_MSE_Data1))
forward_row1<- cbind("Forward Selection",mean_forward_MSE_Data1,median_forward_MSE_Data1)

#Underlying Model 2
forward_MSE_Data2 <- list()

for(i in 1:n_simul2){
  sig2 <- forward(data.frame(X_n_simul2[[i]]),matrix(y_n_simul2[[i]]),"BIC",slentry = 0.5)
  forward_fit2 <- lm(y_n_simul2[[i]] ~ X_n_simul2[[i]][,sig2]+0)
  b2 = array(0,8)
  b2[sig2] = coef(forward_fit2)
  forward_MSE_Data2[[i]] <-   t(beta2-b2)%*%CovarMat2%*%(beta2-b2)
}

mean_forward_MSE_Data2 <- mean(unlist(forward_MSE_Data2))
median_forward_MSE_Data2 <- median(unlist(forward_MSE_Data2))
forward_row2<- cbind("Forward Selection",mean_forward_MSE_Data2,median_forward_MSE_Data2)

#Underlying Model 3
forward_MSE_Data3 <- list()

for(i in 1:n_simul3){
  sig3 <- forward(data.frame(X_n_simul3[[i]]),matrix(y_n_simul3[[i]]),"BIC",slentry = 0.5)
  forward_fit3 <- lm(y_n_simul3[[i]] ~ X_n_simul3[[i]][,sig3]+0)
  b3 = array(0,8)
  b3[sig3] = coef(forward_fit3)
  forward_MSE_Data3[[i]] <-   t(beta3-b3)%*%CovarMat3%*%(beta3-b3)
}

mean_forward_MSE_Data3 <- mean(unlist(forward_MSE_Data3))
median_forward_MSE_Data3 <- median(unlist(forward_MSE_Data3))
forward_row3<- cbind("Forward Selection",mean_forward_MSE_Data3,median_forward_MSE_Data3)
```

## Backward Elimination

We now fit Backward Elimination Regression Models with a cutoff p-value of $0.1$ for the $F$-statistic outlined below, measure model performances, and outline the Forward Selection technnique. According to Hocking (1976) the Backward Elimination technique starts with all variables and eliminates one variable at a time from the equation until either all variables are out or a criteria to stop the technique is satisfied. Furthermore, the variable considered for exclusion at any step is the one yielding the smallest F-ratio among the variables being considered for exclusion if the F-ratio does not exceed a specified value. Thus, the variable $i$ is removed removed from the equation of $p$-terms if

$$
F_{i} = \underset{i}{\min}\left(\frac{RSS_{p-i} - RSS_{p}}{\hat{\sigma}_{p}^2}\right) < F_{out}
$$
R-Implementation:
```{r}
#Underlying Model 1
backward_MSE_Data1 <- list()

for(i in 1:n_simul1){
  sig1 <- backward(X_n_simul1[[i]],matrix(y_n_simul1[[i]]),"BIC",slstay = 0.10)
  backward_fit1 <- lm(y_n_simul1[[i]] ~ X_n_simul1[[i]][,sig1]+0)
  b1 = array(0,8)
  b1[sig1] = coef(backward_fit1)
  backward_MSE_Data1[[i]] <-   t(beta1-b1)%*%CovarMat1%*%(beta1-b1)
}

mean_backward_MSE_Data1 <- mean(unlist(backward_MSE_Data1))
median_backward_MSE_Data1 <- median(unlist(backward_MSE_Data1))
backward_row1<- cbind("Backward Elimination",mean_backward_MSE_Data1,
                     median_backward_MSE_Data1)

#Underlying Model 2
backward_MSE_Data2 <- list()

for(i in 1:n_simul2){
  sig2 <- backward(X_n_simul2[[i]],matrix(y_n_simul2[[i]]),"BIC",slstay = 0.10)
  backward_fit2 <- lm(y_n_simul2[[i]] ~ X_n_simul2[[i]][,sig2]+0)
  b2 = array(0,8)
  b2[sig2] = coef(backward_fit2)
  backward_MSE_Data2[[i]] <-   t(beta2-b2)%*%CovarMat2%*%(beta2-b2)
}

mean_backward_MSE_Data2 <- mean(unlist(backward_MSE_Data2))
median_backward_MSE_Data2 <- median(unlist(backward_MSE_Data2))
backward_row2<- cbind("Backward Elimination",mean_backward_MSE_Data2,
                     median_backward_MSE_Data2)

#Underlying Model 3
backward_MSE_Data3 <- list()

for(i in 1:n_simul3){
  sig3 <- backward(X_n_simul3[[i]],matrix(y_n_simul3[[i]]),"BIC",slstay = 0.10)
  backward_fit3 <- lm(y_n_simul3[[i]] ~ X_n_simul3[[i]][,sig3]+0)
  b3 = array(0,8)
  b3[sig3] = coef(backward_fit3)
  backward_MSE_Data3[[i]] <-   t(beta3-b3)%*%CovarMat3%*%(beta3-b3)
}

mean_backward_MSE_Data3 <- mean(unlist(backward_MSE_Data3))
median_backward_MSE_Data3 <- median(unlist(backward_MSE_Data3))
backward_row3<- cbind("Backward Elimination",mean_backward_MSE_Data3,
                     median_backward_MSE_Data3)
```

## Stepwise Selection

We now fit Stepwise Selection Regression Models with an entry cutoff p-value of $0.15$ and a removal cutoff p-value of $0.15$ , measure model performances, and outline the Forward Selection technnique. According to Hocking (1976) the Stepwise Selection technique is a combination of both Forward Selection and Backward Elimination such that variables are added as in Forward Selection, but then after adding a variable, all variables in the equation can be removed as in Backward Eliminination.

R-Implementation:
```{r}
#Underlying Model 1
stepwise_MSE_Data1 <- list()

for(i in 1:n_simul1){
  sig1 <- stepwise(X_n_simul1[[i]],matrix(y_n_simul1[[i]]),"BIC",slentry=0.15,slstay=0.15)
  stepwise_fit1 <- lm(y_n_simul1[[i]] ~ X_n_simul1[[i]][,sig1]+0)
  b1 = array(0,8)
  b1[sig1] = coef(stepwise_fit1)
   stepwise_MSE_Data1[[i]] <-   t(beta1-b1)%*%CovarMat1%*%(beta1-b1)
}

mean_stepwise_MSE_Data1 <- mean(unlist(stepwise_MSE_Data1))
median_stepwise_MSE_Data1 <- median(unlist(stepwise_MSE_Data1))
stepwise_row1<- cbind("Stepwise Selection",mean_stepwise_MSE_Data1,
                     median_stepwise_MSE_Data1)

#Underlying Model 2
stepwise_MSE_Data2 <- list()

for(i in 1:n_simul2){
  sig2 <- stepwise(X_n_simul2[[i]],matrix(y_n_simul2[[i]]),"BIC",slentry=0.15,slstay=0.15)
  stepwise_fit2 <- lm(y_n_simul2[[i]] ~ X_n_simul2[[i]][,sig2]+0)
  b2 = array(0,8)
  b2[sig2] = coef(stepwise_fit2)
   stepwise_MSE_Data2[[i]] <-   t(beta2-b2)%*%CovarMat2%*%(beta2-b2)
}

mean_stepwise_MSE_Data2 <- mean(unlist(stepwise_MSE_Data2))
median_stepwise_MSE_Data2 <- median(unlist(stepwise_MSE_Data2))
stepwise_row2<- cbind("Stepwise Selection",mean_stepwise_MSE_Data2,
                     median_stepwise_MSE_Data2)

#Underlying Model 3
stepwise_MSE_Data3 <- list()

for(i in 1:n_simul3){
  sig3 <- stepwise(X_n_simul3[[i]],matrix(y_n_simul3[[i]]),"BIC",slentry=0.15,slstay=0.15)
  stepwise_fit3 <- lm(y_n_simul3[[i]] ~ X_n_simul3[[i]][,sig3]+0)
  b3 = array(0,8)
  b3[sig3] = coef(stepwise_fit3)
   stepwise_MSE_Data3[[i]] <-   t(beta3-b3)%*%CovarMat3%*%(beta3-b3)
}

mean_stepwise_MSE_Data3 <- mean(unlist(stepwise_MSE_Data3))
median_stepwise_MSE_Data3 <- median(unlist(stepwise_MSE_Data3))
stepwise_row3<- cbind("Stepwise Selection",mean_stepwise_MSE_Data3,
                     median_stepwise_MSE_Data3)
```

# Results and Discussion
## Performance Metrics


- <span style="color:black; font-weight:bold"> General MSE Results on Underlying Models:</span> As expected OLS performs worst, although it is important to note that LASSO and Ridge have similar mean and median MSE scores, which does seem odd, since the median MSE is more robust to outlying values. We observe that the computational methods perform well concerning mean and median MSE relative to other methods.

Results Table:
```{r,echo=FALSE}
Table_MSE1 <- data.frame(rbind(OLS_row1,LASSO_row1,Ridge_row1,All_possible_row1
                        ,forward_row1,backward_row1,stepwise_row1))
colnames(Table_MSE1) <- c("Method","Mean MSE","Median MSE")

Table_MSE2 <- data.frame(rbind(OLS_row2,LASSO_row2,Ridge_row2,All_possible_row2
                        ,forward_row2,backward_row2,stepwise_row2))
colnames(Table_MSE2) <- c("Method","Mean MSE","Median MSE")


Table_MSE3 <- data.frame(rbind(OLS_row3,LASSO_row3,Ridge_row3,All_possible_row3
                        ,forward_row3,backward_row3,stepwise_row3))
colnames(Table_MSE3) <- c("Method","Mean MSE","Median MSE")


Table_MSE <- cbind(Table_MSE1, Table_MSE2[,-1], Table_MSE3[,-1])

Table_MSE[, c(2:7)] <- sapply(Table_MSE[, c(2:7)], as.numeric)

Table_MSE[, c(2:7)] <- round(Table_MSE[, c(2:7)],4)

kable(Table_MSE) %>%
  kable_styling("striped") %>%
  add_header_above(c(" " = 1, "Underlying Model 1" = 2, "Underlying Model 2" = 2, "Underlying Model 3" = 2))
```



## Plots


- <span style="color:black; font-weight:bold">Plotting General MSE:</span> As expected OLS performs worst, although it is important to note that LASSO and Ridge have similar mean and median MSE scores, which does seem odd, since the median MSE is more robust to outlying values. We observe that the computational methods perform well concerning mean and median MSE relative to other methods.

```{r,warning=FALSE,message=FALSE,echo=FALSE}
MSE_df <- data.frame(
            OLS = c(OLS_MSE_Data1,
                    OLS_MSE_Data2,
                    OLS_MSE_Data3),
            LASSO = c(LASSO_MSE_Data1,
                    LASSO_MSE_Data2,
                    LASSO_MSE_Data3),
            Ridge = c(Ridge_MSE_Data1,
                    Ridge_MSE_Data2,
                    Ridge_MSE_Data3),
           `All Possible Regression` = c(unlist(All_possible_MSE_Data1),
                    unlist(All_possible_MSE_Data2),
                    unlist(All_possible_MSE_Data3)),
           `Forward Selection` = c(unlist(forward_MSE_Data1),
                    unlist(forward_MSE_Data2),
                    unlist(forward_MSE_Data3)),
           `Backward Elimination` = c(unlist(backward_MSE_Data1),
                    unlist(backward_MSE_Data2),
                    unlist(backward_MSE_Data3)),
  `Stepwise Selection` = c(unlist(stepwise_MSE_Data1),
                    unlist(stepwise_MSE_Data2),
                    unlist(stepwise_MSE_Data3))
)

gathered_data <- gather(MSE_df, key = "key", value = "value")

colnames(gathered_data) <- c("key","value")

gathered_data %>%
  ggplot( aes(reorder(key, value, FUN = median, .desc =TRUE), y=value, fill=key)) +
    geom_boxplot() +
    ylim(0,15) +
    scale_fill_viridis(discrete = TRUE, alpha=0.5) +
    geom_jitter(color="black", size=0.4, alpha=0.8) +
    theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)) +
    coord_flip() +
    labs(title = "MSE Distribution over all Models",
      x="Variable Selection Technique",
      y="MSE")
```

- <span style="color:black; font-weight:bold"> Plotting Mean and Median MSE by Variable Selection Technique:</span> As expected OLS performs worst, although it is important to note that LASSO and Ridge have similar mean and median MSE scores, which does seem odd, since the median MSE is more robust to outlying values. We observe that the computational methods perform well concerning mean and median MSE relative to other methods.

```{r,warning=FALSE,message=FALSE,echo=FALSE}
Table_MSE_New <- rbind(Table_MSE[,c(1,2,3)],Table_MSE[,c(1,4,5)],Table_MSE[,c(1,6,7)])
gathered_MSE <- gather(Table_MSE_New , key = "key", value = "value",-Method)
colnames(gathered_MSE) <- c("method","metric","value")

ggplot(data = gathered_MSE, aes(x=method, y=value)) + 
  geom_boxplot(aes(fill=metric)) +
  facet_wrap( ~ method, scales="free") +
  theme_light()
```

- <span style="color:black; font-weight:bold"> Plotting Mean and Median MSE by Underlying Model:</span> As expected OLS performs worst, although it is important to note that LASSO and Ridge have similar mean and median MSE scores, which does seem odd, since the median MSE is more robust to outlying values. We observe that the computational methods perform well concerning mean and median MSE relative to other methods.

```{r,warning=FALSE,message=FALSE}

```


# References

## Papers
* Tibshirani, R. (1996). Regression Shrinkage and Selection Via the Lasso. Journal of the Royal Statistical Society: Series B (Methodological), 58: 267-288. doi:<!-- -->10.1111/j.251<!-- -->7-6161.1996.tb02080.x

* Hocking, R. (1976). A Biometrics Invited Paper. The Analysis and Selection of Variables in Linear Regression. Biometrics, 32(1), 1-49. doi:<!-- -->10.230<!-- -->7/2529336

## Books
* James, G.; Witten, D.; Hastie, T. & Tibshirani, R. (2013), An Introduction to Statistical Learning: with Applications in R. Springer. doi:<!-- -->10.1007/978-1-4<!-- -->614-7138-7

## R Packages
* glmnet
* knitr
* foreach
* MASS
* rlist
* rmarkdown
* dvmisc
* kableExtra
* ggplot2
* tidyr
* hrbrthemes
* viridis
